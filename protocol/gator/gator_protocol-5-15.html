<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <style type="text/css">
      .circle {
        -webkit-border-radius: 999px;
        -moz-border-radius: 999px;
        border-radius: 999px;
        border: 1px solid #003366;
        padding: 2px;
      }
      .white {
        color: white;
      }
      table {
        border-spacing: 0px;
        border-bottom: 1px solid gray;
        border-right: 1px solid gray;
      }
      th, td {
        padding: 2px;
        vertical-align: text-top;
        border-left: 1px solid gray;
        border-top: 1px solid gray;
      }
      th {
        background-color: #687684;
      }
      table.none {
        border: 0px;
      }
      table.none td {
        border: 0px;
      }
      .literal {
        font-family: monospace;
      }
    </style>
    <script type="text/javascript" src="../topbar.js"></script>
  </head>
  <body>
    <div class="master">
    <h1 id="top">Gator v14 (DS-5 v5.15) Protocol</h1>
    <h2 id="Index">Index</h2>
    <li>
      <a href="#Introduction">Introduction</a>
    </li>
    <li><a href="#ChangesInV14">Changes in v14 (DS-5 v5.15)</a></li>
    <li><a href="#ChangesInV13">Changes in v13 (DS-5 v5.14)</a></li>
    <li>
      <a href="#Protocol">Target-Host Protocol</a>
      <ul>
	<li><a href="#Magic">Magic Exchange</a></li>
	<li><a href="#CommandHeader">Command Header</a></li>
	<li><a href="#CommandRequestXML">Request XML Body</a></li>
	<li><a href="#CommandDeliverXML">Deliver XML Body</a></li>
	<li><a href="#CommandAPCStart">APC Start Body</a></li>
	<li><a href="#CommandAPCStop">APC Stop Body</a></li>
	<li><a href="#CommandDisconnect">Disconnect Body</a></li>
	<li><a href="#CommandPing">Ping Body</a></li>
      </ul>
    </li>
    <li>
      <a href="#Response">Response Format</a>
      <ul>
	<li><a href="#ResponseHeader">Response Header</a></li>
	<li><a href="#ResponseXML">XML Body</a></li>
	<li><a href="#ResponseApcData">APC Data Body</a></li>
	<li><a href="#ResponseAck">ACK Body</a></li>
	<li><a href="#ResponseNak">NAK Body</a></li>
	<li><a href="#ResponseError">Error Body</a></li>
      </ul>
    </li>
    <li>
      <a href="#XML">XML</a>
      <ul>
	<li><a href="#XMLEvents">Events</a></li>
	<li><a href="#XMLConfiguration">Configuration</a></li>
	<li><a href="#XMLCounters">Counters</a></li>
	<li><a href="#XMLSession">Session</a></li>
	<li><a href="#XMLCaptured">Captured</a></li>
      </ul>
    </li>
    <li>
      <a href="#Frame">APC Frame Format</a>
      <ul>
	<li><a href="#Overview">Overview</a></li>
	<li><a href="#FrameTypes">Types</a></li>
	<li><a href="#FramePacked">Packed Values</a></li>
	<li><a href="#FrameOrdering">Ordering</a></li>
	<li><a href="#FrameRequired">Required Messages</a></li>
	<li><a href="#FrameHeader">Frame Header</a></li>
	<li><a href="#FrameSummary">Summary Frame Messages</a></li>
	<li><a href="#FrameBacktrace">Backtrace Frame Messages</a></li>
	<li><a href="#FrameName">Name Frame Messages</a></li>
	<li><a href="#FrameCounter">Counter Frame Messages</a></li>
	<li><a href="#FrameBlockCounter">Block Counter Frame Messages</a></li>
	<li><a href="#FrameAnnotate">Annotate Frame Messages</a></li>
	<li><a href="#FrameSched">Scheduler Trace Frame Messages</a></li>
	<li><a href="#FrameGPU">GPU Trace Frame Messages</a></li>
	<li><a href="#FrameIdle">Idle Frame Messages</a></li>
      </ul>
    </li>
    <li>
      <a href="#Sequence">Sequence Diagrams</a>
      <ul>
	<li><a href="#SequenceConfig">Configuration</a></li>
	<li><a href="#SequenceCapture">Capture</a></li>
      </ul>
    </li>
    <li>
      <a href="#LocalCapture">Local Capture</a>
    </li>
    <h2 id="Introduction">Introduction</h2>
    <p>This document describes the TCP/IP protocol used by gator or other implementing clients to communicate with Streamline version 5.15 or later. Use this information to build a customized client to communicate profiling data to Streamline. The gator source code, distributed as part of <a href="http://www.arm.com/products/tools/software-tools/ds-5/index.php">DS-5</a>, is the reference implementation of this protocol. The protocol may change with future releases of Streamline, but Streamline will maintain backwards compatibility with this version of the protocol so that clients need only implement one version of the protocol. Streamline requires that your client is able to parse and generate simple XML and ignore additional or unexpected nodes or attributes. Because the XML features described in this protocol documentation are the only ones used, Streamline does not require the more complex features of XML.</p>
    <h2 id="ChangesInV14">Changes in v14 (DS-5 v5.15)</h2>
    <p>gator v14, the version of gator shipped with Streamline version 5.15, has a few important updates that you should familiarize yourself with before implementing or updating your own customized Streamline TCP/IP protocol.</p>
    <ul>
      <li>Added the backtrace_processing attribute to <a href="#XMLCaptured">Captured XML</a> to allow call stack post-processing to be disabled</li>
      <li>Improved the <a href="#Magic">Magic Exchange</a> so that Streamline sends its version</li>
      <li>Added series_composition, rendering_type, average_cores, percentage, and derived to <a href="#XMLEvents">Events XML</a></li>
      <li>Remove unneeded attributes from <a href="#XMLConfiguration">Configuration XML</a> and <a href="#XMLCaptured">Captured XML</a> and read them from <a href="#XMLEvents">Events XML</a>. This means that events.xml is now required for <a href="#LocalCapture">Local Capture</a>.</li>
      <li>Change <a href="#FramePacked">packing strategy</a> from using LEB128 to SLEB128</li>
      <li>Replace uname in the <a href="#FrameSummary">Summary Message</a> with arbitrary key/value pairs</li>
    </ul>
    <h2 id="ChangesInV13">Changes in v13 (DS-5 v5.14)</h2>
    <p>The following changes have been made in v13 (DS-5 v5.14)</p>
    <ul>
      <li>Streamline no longer requests <a href="#XMLSession">Session XML</a></li>
      <li>Added ways to reduce duplication in <a href="#XMLEvents">Events XML</a> with counter_set and option_set nodes</li>
      <li>Added modifier attribute for <a href="#XMLEvents">Events</a>, <a href="#XMLConfiguration">Configuration</a> and <a href="#XMLCaptured">Captured</a> XML to support fixed-point math</li>
      <li><a href="#XMLConfiguration">Configuration XML</a> version updated to 2</li>
      <li>Added live_rate attribute on in <a href="#XMLSession">Session XML</a> for Live support</li>
      <li>Documented new energy_capture node in <a href="#XMLSession">Session XML</a> released in DS-5 v5.13</li>
      <li>Added cpuid attribute in <a href="#XMLCaptured">Captured XML</a></li>
      <li>Added the Newline Canary to the <a href="#FrameSummary">Summary Frame Message</a> to detect APC corruption</li>
      <li>Added the system uname to the <a href="#FrameSummary">Summary Frame Message</a></li>
      <li>Added cpuid to the <a href="#FrameName">Core Name Message</a></li>
      <li>Documented that <a href="#FrameBlockCounter">Block Counters</a> must always start with a time</li>
      <li>Added the live_energy_delta attribute to the <a href="#XMLCaptured">Captured XML</a> file</li>
    </ul>
    <h2 id="Protocol">Target-Host Protocol</h2>
    <h3 id="Magic">Magic Exchange</h3>
    <p>A handshake is required so that your target and client can recognize each other. It consists of ASCII newline (\n) delimited strings. If the client receives a string it does not recognize, the string must be discarded and another string is read.</p>
    <p>The standard Streamline client is gator. But, as you can customize gator and call it what you wish, the term client is used generically to refer to your customized protocol.</p>
    <ol>
      <li>The client receives Streamlines highest supported protocol version <span class="literal">VERSION $VER\n</span>, for example if Streamline supports up to version 23, the client would recieve <span class="literal">VERSION 23\n</span>.</li>
      <li>The client receives <span class="literal">STREAMLINE\n</span></li>
      <li>Send <span class="literal">GATOR 14\n</span></li>
    </ol>
    <p>Further communication from Streamline comes as <a href="#CommandHeader">Commands</a></p>
    <h3 id="CommandHeader">Command Header</h3>
    <p>Streamline issues commands that consist of a header and a body. Streamline expects a <a href="#Response">Response</a> to these commands from the client.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td>int8</td>
	<td>The type of command
	  <table class="none">
	    <tr><td>0</td><td>= <a href="#CommandRequestXML">Request XML</a></td></tr>
            <tr><td>1</td><td>= <a href="#CommandDeliverXML">Deliver XML</a></td></tr>
            <tr><td>2</td><td>= <a href="#CommandAPCStart">APC Start</a></td></tr>
            <tr><td>3</td><td>= <a href="#CommandAPCStop">APC Stop</a></td></tr>
            <tr><td>4</td><td>= <a href="#CommandDisconnect">Disconnect</a></td></tr>
            <tr><td>5</td><td>= <a href="#CommandPing">Ping</a></td></tr>
	  </table>
	</td>
      </tr>
      <tr>
	<td>Length</td>
	<td>Little Endian int32</td>
	<td>Number of bytes in the body</td>
      </tr>
    </table></p>
    <p>If the client receives an unrecognized command, it should respond with a <a href="#ResponseNak">NAK</a>.</p>
    <h3 id="CommandRequestXML">Request XML Body</h3>
    <p>Command code 0 is a request from Streamline for XML. The root node is request and it has the type attribute that tells the client which xml is required. For example, this is a request for <a href="#XMLEvents">Events XML</a></p>
    <p class="literal">
      &lt;?xml version="1.0" encoding="US-ASCII"?&gt;<br/>
      &lt;request type="events"&gt;<br/>
      &lt;/request&gt;
    </p>
    <p><table>
      <tr>
	<th><span class="white">Request</span></th>
	<th><span class="white">Response Code</span></th>
	<th><span class="white">Response Body</span></th>
      </tr>
      <tr>
	<td><span class="literal">&lt;request type="events"&gt;</span></td>
	<td>XML</td>
	<td><a href="#XMLEvents">Events XML</a></td>
      </tr>
      <tr>
	<td><span class="literal">&lt;request type="configuration"&gt;</span></td>
	<td>XML</td>
	<td><a href="#XMLConfiguration">Configuration XML</a></td>
      </tr>
      <tr>
	<td><span class="literal">&lt;request type="counters"&gt;</span></td>
	<td>XML</td>
	<td><a href="#XMLCounters">Counters XML</a></td>
      </tr>
      <tr>
	<td><span class="literal">&lt;request type="captured"&gt;</span></td>
	<td>XML</td>
	<td><a href="#XMLCaptured">Captured XML</a> Streamline requests Captured XML prior to starting a capture.</td>
      </tr>
      <tr>
	<td><span class="literal">&lt;request type="defaults"&gt;</span></td>
	<td>XML</td>
	<td>default <a href="#XMLConfiguration">Configuration XML</a></td>
      </tr>
    </table></p>
    <h3 id="CommandDeliverXML">Deliver XML Body</h3>
    <p>The Deliver XML command sends XML to the client:</p>
    <p><table>
      <tr>
	<th><span class="white">Request</span></th>
	<th><span class="white">Response Code</span></th>
      </tr>
      <tr>
	<td><a href="#XMLSession">Session XML</a></td>
	<td>ACK</td>
      </tr>
      <tr>
	<td><a href="#XMLConfiguration">Configuration XML</a></td>
	<td>ACK</td>
      </tr>
    </table></p>
    <h3 id="CommandAPCStart">APC Start Body</h3>
    <p>The APC Start command does not have a body. This command initiates a capture and readies Streamline to receive <a href="#ResponseApcData">APC Data Responses</a>. No ACK is expected and no further XML exchange takes place. If a failure occurs, the client should send an <a href="#ResponseError">Error</a>.</p>
    <h3 id="CommandAPCStop">APC Stop Body</h3>
    <p>The APC Stop command also does not have a body. This command triggers the end of the APC and no ACK is expected. <a href="#ResponseApcData">APC Data Responses</a> can continue to arrive until all captured data is sent, then the connection should be closed. If a failure occurs, the client should send an <a href="#ResponseError">Error</a>.</p>
    <h3 id="CommandDisconnect">Disconnect Body</h3>
    <p>The Disconnect command, which closes the connection to the target, does not contain a command body. No ACK is expected.</p>
    <h3 id="CommandPing">Ping Body</h3>
    <p>The Ping command does not have a body. Send an ACK response to this command.</p>
    <h2 id="Response">Response Format</h2>
    <p>Responses consist of a header followed by a body</p>
    <h3 id="ResponseHeader">Response Header</h3>
    <p>The format for the response header is identical to that of the <a href="#CommandHeader">Command Header</a> but the Codes are different</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td>int8</td>
	<td>The type of command
	  <table class="none">
	    <tr><td>1</td><td>= <a href="#ResponseXML">XML</a></td></tr>
	    <tr><td>3</td><td>= <a href="#ResponseApcData">APC Data</a></td></tr>
	    <tr><td>4</td><td>= <a href="#ResponseAck">ACK</a></td></tr>
	    <tr><td>5</td><td>= <a href="#ResponseNak">NAK</a></td></tr>
	    <tr><td>0xFF</td><td>= <a href="#ResponseError">Error</a></td></tr>
	  </table>
	</td>
      </tr>
      <tr>
	<td>Length</td>
	<td>Little Endian int32</td>
	<td>Number of bytes in the body</td>
      </tr>
    </table></p>
    <h3 id="ResponseXML">XML Body</h3>
    <p>The body should contain XML, the format of which is dependent on the Request type. For a list of types, see <a href="#CommandRequestXML">Request XML Body</a></p>
    <h3 id="ResponseApcData">APC Data Body</h3>
    <p>The APC body should contain an <a href="#Frame">APC Frame</a>. If the length is zero, it is the End of Sequence message which indicates that all APC Frames have been transmitted to Streamline.</p>
    <h3 id="ResponseAck">ACK Body</h3>
    <p>This response, which indicates the <a href="#CommandHeader">Command</a> was successful, does not have a response body.</p>
    <h3 id="ResponseNak">NAK Body</h3>
    <p>Indicates a synchronous non-fatal error occurred when handling a request. It can contain a UTF-8 error message. The length is specified in the header, so no NULL character is expected. Indicates that the <a href="#CommandHeader">Command</a> failed, but that the connection can continue.</p>
    <h3 id="ResponseError">Error Body</h3>
    <p>Indicates a synchronous fatal error occurred when responding to a request. A UTF-8 error message. The length is specified in the header, so no NULL character is expected. Use this response when the error is terminal and the connection must be closed. Errors may be sent without a request, but Streamline may not process them immediately.</p>
    <h2 id="XML">XML</h2>
    <h3 id="XMLEvents">Events</h3>
    <p>The Events XML defines the list of counters that you can choose from in the Counter Configuration dialog box. Modify this list to create your own custom counters.</p>
    <p><b>events</b></p>
    <p>The events root node of Events XML can have any number of counter_set and category child nodes.</p>
    <p><b>counter_set</b></p>
    <p>The counter_set node has no children and the following attributes. Counter sets are used when the number of counters that can be enabled in a category is restricted. Streamline will respect the restriction and assign a name from the set to a counter in <a href="#XMLConfiguration">Configuration XML</a>.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>name</td>
	<td>String</td>
	<td>Name of the counter_set</td>
      </tr>
      <tr>
	<td>count</td>
	<td>String</td>
	<td>Number of counters in the set. Counter names are derived by appending a number, starting at zero, to the set name. Ex, if the set name is ARM_Cortex-A8_cnt and the count is 4, then the counter names in the set are ARM_Cortex-A8_cnt0, ARM_Cortex-A8_cnt1, ARM_Cortex-A8_cnt2 and ARM_Cortex-A8_cnt3</td>
      </tr>
      <tr>
	<td>title</td>
	<td>String</td>
	<td>Appended to the title of the event when counter_set is a child of category, shown in Streamline before the name. Used to group counters.</td>
      </tr>
      <tr>
	<td>description</td>
	<td>String</td>
	<td>The value of this attribute is appended to the description to show in Streamline when counter_set is a child of category. Used as the tooltip for the counter</td>
      </tr>
    </table></p>
    <p><b>category</b></p>
    <p>The category node can have any number of event and option_set child nodes. It can also have one or more counter_set child nodes instead of the counter_set attribute if the same set of child event nodes show up for to multiple counter sets.  The category node can have the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>name</td>
	<td>String</td>
	<td>The name of the category. The value given here appears as the category name in the Counter Configuration dialog box in Streamline.</td>
      </tr>
      <tr>
	<td>counter_set</td>
	<td>String</td>
	<td>Defines the counter_set to be used. You must use this attribute if any child event uses the event attribute and there are no child counter_set nodes present. </td>
      </tr>
      <tr>
	<td>per_cpu</td>
	<td>Boolean</td>
	<td>Defines whether or not Streamline collects data on a per cpu basis. Set this value to yes and Streamline collects data from each cpu separately for these counters. The default value is no.</td>
      </tr>
      <tr>
	<td>supports_event_based_sampling</td>
	<td>Boolean</td>
	<td>Use yes or no to define whether or not the counters in this category can be used for event based sampling. The default value is no.</td>
      </tr>
    </table></p>
    <p><b>option_set</b></p>
    <p>The event node has one or more option_set child nodes and the following attributes. Use this node when the same event applies to multiple devices. It has the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>name</td>
	<td>String</td>
	<td>The name of this option_set</td>
      </tr>
    </table></p>
    <p><b>option</b></p>
    <p>The option_set node contains one or more option child nodes. The option node has no children and the following attributes</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>event_delta</td>
	<td>Hex Integer</td>
	<td>The offset to add to the applicable event to get the event number.</td>
      </tr>
      <tr>
	<td>name</td>
	<td>String</td>
	<td>The name of the device. The value of name is appended to the event name.</td>
      </tr>
      <tr>
	<td>description</td>
	<td>String</td>
	<td>A description of the device option. This description is appended to the event description.</td>
      </tr>
    </table></p>
    <p><b>event</b></p>
    <p>The event node has no children and the following attributes</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>counter</td>
	<td>String</td>
	<td>Every event element must have either the counter or event attribute defined. Use the counter attribute for fixed counter types, like cycle count. Use the event attribute for all other events. The counter attribute is the name of the counter.</td>
      </tr>
      <tr>
	<td>event</td>
	<td>Hex Integer</td>
	<td>	Architecture specific or implementation-specific event number, in hexadecimal, determined from either the architecture specification document or the Technical Reference Manual of the processor. This attribute is required if the element does not have a counter attribute.</td>
      </tr>
      <tr>
	<td>option_set</td>
	<td>String</td>
	<td>The name of the option_set to use.</td>
      </tr>
      <tr>
	<td>title</td>
	<td>String</td>
	<td>Title of the event, shown in Streamline before the name. Use this attribute to group counters.</td>
      </tr>
      <tr>
	<td>name</td>
	<td>String</td>
	<td>Name of the event, shown in Streamline after the title.</td>
      </tr>
      <tr>
	<td>per_cpu</td>
	<td>Boolean</td>
	<td>Defines whether or not Streamline collects data on a per cpu basis. Set this value to yes and Streamline collects data from each cpu separately for this event. The default is the value of the per_cpu attribute of the category node.</td>
      </tr>
      <tr>
	<td>supports_event_based_sampling</td>
	<td>Boolean</td>
	<td>Use yes or no to define whether or not the event can be used for event based sampling. This value defaults to the category value if the attribute is not present in the event.</td>
      </tr>
      <tr>
	<td>display</td>
	<td>String</td>
	<td>Use one of the following values with the display attribute: average, maximum, minimum, hertz, accumulate. This is the same as adding .avg, .max, .min or .hz to the counter name in the chart configuration panel of Streamline. The default value is accumulate. This attribute is optional.</td>
      </tr>
      <tr>
	<td>units</td>
	<td>String</td>
	<td>Defines the unit type to display in Streamline. This attribute is optional.</td>
      </tr>
      <tr>
	<td>modifier</td>
	<td>Integer</td>
	<td>Optional, number to divide read numbers by for fixed point math. This attribute is optional.</td>
      </tr>
      <tr>
	<td>derived</td>
	<td>Boolean</td>
	<td>Defines whether or not the the data is derived from the data of another chart.</td>
      </tr>
      <tr>
	<td>series_composition</td>
	<td>String</td>
	<td>Defines how to arrange the data in the Timeline view. Enter either overlay or stacked as the value for this attribute. This attribute is optional and the default value is stacked.</td>
      </tr>
      <tr>
	<td>rendering_type</td>
	<td>String</td>
	<td>The type of chart to render for the Timeline view in Streamline. This attribute is optional and can be set to either bar, line, or fill. The default value is fill.</td>
      </tr>
      <tr>
	<td>average_selection</td>
	<td>Boolean</td>
	<td>Sets whether or not average values are displayed by the Cross Section Marker in Streamline. This attribute is optional.</td>
      </tr>
      <tr>
	<td>average_cores</td>
	<td>Boolean</td>
	<td>Set whether or not Streamline averages the values of multiple cores when viewing the aggregate data of a per-cpu chart. This attribute is optional.</td>
      </tr>
      <tr>
	<td>percentage</td>
	<td>Boolean</td>
	<td>Optional, Sets whether or not the Timeline view displays data as a percentage of the maximum value in the chart.</td>
      </tr>
      <tr>
	<td>description</td>
	<td>String</td>
	<td>Use this attribute to define a description to show in Streamline. The value of this attribute is used as the tooltip for the counter.</td>
      </tr>
    </table></p>
    <p>Events XML example:</p>
    <p class="literal">
      &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>
      &lt;events&gt;<br/>
      &nbsp;&nbsp;&lt;counter_set name="ARM_Cortex-A8_cnt" count="4"/&gt;<br/>
      &nbsp;&nbsp;&lt;category name="Cortex-A8" counter_set="ARM_Cortex-A8_cnt" per_cpu="yes" supports_event_based_sampling="yes"&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event counter="ARM_Cortex-A8_ccnt" event="0xff" title="Clock" name="Cycles" display="hertz" units="Hz" average_selection="yes" description="The number of core clock cycles"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x0" title="Software" name="Increment" description="Incremented only on writes to the Software Increment Register"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x1" title="Cache" name="Instruction refill" description="Instruction fetch that causes a refill of at least the level of instruction or unified cache closest to the processor"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&lt;/category&gt;<br/>
      &nbsp;&nbsp;&lt;category name="CCI-400" counter_set="cci-400_cnt" supports_event_based_sampling="yes"&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event counter="cci-400_ccnt" event="0xff" title="CCI-400" name="Cycles" display="hertz" units="Hz" average_selection="yes" description="The number of core clock cycles"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;option_set name="Slave"&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option event_delta="0x0" name="S0" description="Slave interface 0"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option event_delta="0x20" name="S1" description="Slave interface 1"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option event_delta="0x40" name="S2" description="Slave interface 2"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;/option_set&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x0" option_set="Slave" title="CCI-400" name="Read: any" description="Read request handshake: any"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x1" option_set="Slave" title="CCI-400" name="Read: transaction" description="Read request handshake: device transaction"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x2" option_set="Slave" title="CCI-400" name="Read: normal" description="Read request handshake: normal, non-shareable or system-shareable, but not barrier or cache maintenance operation"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;option_set name="Master"&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option event_delta="0xa0" name="M0" description="Master interface 0"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option event_delta="0xc0" name="M1" description="Master interface 1"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option event_delta="0xe0" name="M2" description="Master interface 2"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;/option_set&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x14" option_set="Master" title="CCI-400" name="Retry fetch" description="RETRY of speculative fetch transaction"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x15" option_set="Master" title="CCI-400" name="Read stall: address hazard" description="Read request stall cycle because of an address hazard"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x16" option_set="Master" title="CCI-400" name="Read stall: ID hazard" description="Read request stall cycle because of an ID hazard"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&lt;/category&gt;<br/>
      &nbsp;&nbsp;&lt;category name="Mali GPU Fragment Processor"&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter_set name="ARM_Mali-400_FP0_cnt" title="Mali-400 FP0" description="Mali GPU Fragment Processor 0" count="2"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter_set name="ARM_Mali-400_FP1_cnt" title="Mali-400 FP1" description="Mali GPU Fragment Processor 1" count="2"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter_set name="ARM_Mali-400_FP2_cnt" title="Mali-400 FP2" description="Mali GPU Fragment Processor 2" count="2"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x0" title="Mali-400 FP" name="Active clock cycles" description="Active clock cycles, between polygon start and IRQ."/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x2" title="Mali-400 FP" name="Total bus reads" description="Total number of 64-bit words read from the bus."/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event event="0x3" title="Mali-400 FP" name="Total bus writes" description="Total number of 64-bit words written to the bus."/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&lt;/category&gt;<br/>
      &nbsp;&nbsp;&lt;category name="Linux"&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event counter="Linux_irq_softirq" title="Interrupts" name="SoftIRQ" per_cpu="yes" description="Linux SoftIRQ taken"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event counter="Linux_irq_irq" title="Interrupts" name="IRQ" per_cpu="yes" description="Linux IRQ taken"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event counter="Linux_block_rq_wr" title="Disk IO" name="Write" units="B" description="Disk IO Bytes Written"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&lt;/category&gt;<br/>
      &nbsp;&nbsp;&lt;category name="hwmon"&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event counter="hwmon_ab8500-isa-0000_0" title="Temperature" name="ext_rtc_xtal" display="average" units="C" modifier="1000" average_selection="yes" description="libsensors Temperature sensor ext_rtc_xtal (hwmon_ab8500-isa-0000_0)"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event counter="hwmon_ab8500-isa-0000_1" title="Temperature" name="ext_db8500" display="average" units="C" modifier="1000" average_selection="yes" description="libsensors Temperature sensor ext_db8500 (hwmon_ab8500-isa-0000_1)"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;event counter="hwmon_ab8500-isa-0000_2" title="Temperature" name="bat_temp" display="average" units="C" modifier="1000" average_selection="yes" description="libsensors Temperature sensor bat_temp (hwmon_ab8500-isa-0000_2)"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;<br/>
      &nbsp;&nbsp;&lt;/category&gt;<br/>
      &lt;/events&gt;
    </p>
    <h3 id="XMLConfiguration">Configuration</h3>
    <p>Configuration XML defines the set of counters that are enabled for a capture session. It is sent to the client using the Deliver XML command. Any counters listed in Configuration XML that are not available on the target are ignored.</p>
    <p><b>configurations</b></p>
    <p>The configurations root node of Configuration XML can have any number of configuration child nodes and has one attribute:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>revision</td>
	<td>Integer</td>
	<td><span class="circle">2</span></td>
      </tr>
    </table></p>
    <p><b>configuration</b></p>
    <p>The configuration node has no children and has the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>counter</td>
	<td>String</td>
	<td>Every configuration element must have either the counter or event attribute defined. Use the counter attribute for fixed counter types and the event attribute for all other events. If <a href="#XMLEvents">Events XML</a> did not have a counter for this event, a counter from the related counter_set can be taken. See the description of counter_set in <a href="#XMLEvents">Events XML</a>. This attribute is required.</td>
      </tr>
      <tr>
	<td>event</td>
	<td>Hex Integer</td>
	<td>Architecture-specific or implementation-specific event number, in hexadecimal, determined from either the architecture specification document or the Technical Reference Manual of the processor. This attribute is required if the element does not have a counter attribute.</td>
      </tr>
      <tr>
	<td>count</td>
	<td>Integer</td>
	<td>Tells the client how many samples to collect before triggering the event. This attribute is optional.</td>
      </tr>
    </table></p>
    <p>Configuration XML example:</p>
    <p class="literal">
      &lt;?xml version="1.0" encoding="US-ASCII"?&gt;<br/>
      &lt;configurations revision="2"&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A8_ccnt" event="0xFF"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A8_cnt0" event="0x8"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A8_cnt1" event="0x44"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A8_cnt2" event="0x43"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A8_cnt3" event="0x10"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A9_ccnt" event="0xFF"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A9_cnt0" event="0x68"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A9_cnt1" event="0x6"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A9_cnt2" event="0x7"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A9_cnt3" event="0x3"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="ARM_Cortex-A9_cnt4" event="0x4"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="Linux_block_rq_wr"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="Linux_block_rq_rd"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="Linux_meminfo_memused"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="Linux_meminfo_memfree"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="Linux_power_cpu_freq"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="cci-400_cnt0" event="0xB4"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="cci-400_cnt1" event="0xD4"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="cci-400_cnt2" event="0xB5"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="hwmon_arm,vexpress-amp-isa-0011_0"/&gt;<br/>
      &nbsp;&nbsp;&lt;configuration counter="hwmon_arm,vexpress-amp-isa-0010_0"/&gt;<br/>
      &lt;/configurations&gt;
    </p>
    <h3 id="XMLCounters">Counters</h3>
    <p>Counters XML lists the counters available on the target.</p>
    <p><b>counters</b></p>
    <p>The counters root node of Counters XML can have any number of counter child nodes</p>
    <p><b>counter</b></p>
    <p>The counter node has the following attribute</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>name</td>
	<td>String</td>
	<td>An available counter name from counter_set or the counter attribute of the event node.</td>
      </tr>
    </table></p>
    <p>Counters XML Example:</p>
    <p class="literal">
      &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>
      &lt;counters&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_power_cpu_idle"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_power_cpu_freq"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_sched_switch"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="ARM_Cortex-A8_cnt3"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="ARM_Cortex-A8_cnt2"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="ARM_Cortex-A8_cnt1"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="ARM_Cortex-A8_cnt0"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="ARM_Cortex-A8_ccnt"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_net_tx"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_net_rx"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="mmaped_cnt2"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="mmaped_cnt1"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="mmaped_cnt0"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_meminfo_bufferram"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_meminfo_memused"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_meminfo_memfree"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_irq_softirq"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_irq_irq"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_block_rq_rd"/&gt;<br/>
      &nbsp;&nbsp;&lt;counter name="Linux_block_rq_wr"/&gt;<br/>
      &lt;/counters&gt;
    </p>
    <h3 id="XMLSession">Session</h3>
    <p>Session XML is created by Streamline and delivered to the client. Values in Session XML are based on the settings defined in the Capture & Analysis Options dialog box.</p>
    <p>Note: Session XML must be delivered by Streamline via the Deliver XML command before it is requested by Streamline. Send back the received XML.</p>
    <p><b>session</b></p>
    <p>The session root node of Session XML can have any number of image child nodes, zero or one energy_capture child nodes and has the following attributes</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>version</td>
	<td>Integer</td>
	<td><span class="circle">1</span></td>
      </tr>
      <tr>
	<td>call_stack_unwinding</td>
	<td>Boolean</td>
	<td>The value is yes if the Call Stack Unwinding checkbox is selected, or no if it is not.</td>
      </tr>
      <tr>
	<td>parse_debug_info</td>
	<td>Boolean</td>
	<td>The value is yes if the Process Debug Information checkbox is selected, no if it is not.</td>
      </tr>
      <tr>
	<td>high_resolution</td>
	<td>Boolean</td>
	<td>The value is yes if the High Resolution Timeline checkbox is selected, no if it is not.</td>
      </tr>
      <tr>
	<td>buffer_mode</td>
	<td>String</td>
	<td>The mode chosen using the Buffer Mode drop-down menu. It can set to streaming or one of the following store-and-forward buffers: large - 16MB, medium - 4MB, or small - 1MB. </td>
      </tr>
      <tr>
	<td>sample_rate</td>
	<td>String</td>
	<td>The sample rate chosen using the Sample Rate drop-down menu. It can be set to one of the following options: normal, low, or none. </td>
      </tr>
      <tr>
	<td>duration</td>
	<td>Integer</td>
	<td>The maximum duration of the capture session, in seconds. </td>
      </tr>
      <tr>
	<td>target_host</td>
	<td>String</td>
	<td>The address of the target.</td>
      </tr>
      <tr>
	<td>target_port</td>
	<td>Integer</td>
	<td>The target port.</td>
      </tr>
      <tr>
	<td>live_rate</td>
	<td>String</td>
	<td>The value of this attribute dictates how often, in milliseconds, the <a href="#FrameCounter">Counter</a>, <a href="#FrameBlockCounter">Block Counter</a> and <a href="#FrameSched">Scheduler Trace</a> Frames should be flushed for the Live view.</td>
      </tr>
    </table></p>
    <p><b>image</b></p>
    <p>There is no restriction to the number of image nodes the session node can have. The image node has no child nodes and the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>path</td>
	<td>String</td>
	<td>This attribute defines the Program Image. This attribute can be used during local capture to copy images into the .apc folder. You can update all Program Images in Streamline post-capture.</td>
      </tr>
      <tr>
	<td>enabled</td>
	<td>Boolean</td>
	<td>A yes value means the Program Image is enabled, a no value means it is not. The default value is no.</td>
      </tr>
    </table></p>
    <p><b>energy_capture</b></p>
    <p>The session node can either have zero or one energy_capture child nodes. The energy_capture node can have zero or more channel child nodes and the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>version</td>
	<td>Integer</td>
	<td><span class="circle">1</span></td>
      </tr>
      <tr>
	<td>command_path</td>
	<td>String</td>
	<td>The full path to the caiman executable</td>
      </tr>
      <tr>
	<td>type</td>
	<td>String</td>
	<td>The type attribute can have one of three possible values: none, energy_probe or ni-daq. none means no energy data is collected during a capture. energy_probe or ni-daq define the hardware used to capture the energy data from the target.</td>
      </tr>
    </table></p>
    <p><b>channel</b></p>
    <p>The energy_capture node can any number of channel nodes. The channel node has the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>id</td>
	<td>Integer</td>
	<td>The channel number</td>
      </tr>
      <tr>
	<td>resistance</td>
	<td>Integer</td>
	<td>The channel resistance, set using the resistance field.</td>
      </tr>
      <tr>
	<td>power</td>
	<td>Boolean</td>
	<td>True if power data is to be collected and displayed</td>
      </tr>
      <tr>
	<td>voltage</td>
	<td>Boolean</td>
	<td>Set to yes if the Voltage checkbox has been enabled for this channel.</td>
      </tr>
      <tr>
	<td>current</td>
	<td>Boolean</td>
	<td>Set to yes if the Current checkbox has been enabled for this channel.</td>
      </tr>
    </table></p>
    <p>Example:</p>
    <p class="literal">
      &lt;?xml version="1.0" encoding="US-ASCII"?&gt;<br/>
      &lt;session version="1" call_stack_unwinding="yes" parse_debug_info="yes" high_resolution="no" buffer_mode="streaming" sample_rate="low" duration="0" target_host="10.99.3.109" target_port="8080" live_rate="100"&gt;<br/>
      &nbsp;&nbsp;&lt;image path="H:\ls"/&gt;<br/>
      &nbsp;&nbsp;&lt;image path="H:\libc.so.6"/&gt;<br/>
      &nbsp;&nbsp;&lt;energy_capture version="1" command_path="C:\Program Files (x86)\DS-5\bin\caiman.exe" type="none"&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;channel id="0" resistance="20" power="yes" voltage="yes" current="yes"/&gt;<br/>
      &nbsp;&nbsp;&lt;/energy_capture&gt;<br/>
      &lt;/session&gt;
    </p>
    <h3 id="XMLCaptured">Captured</h3>
    <p>Captured XML contains information about a capture session. This is very similar to <a href="#XMLConfiguration">Configuration XML</a></p>
    <p><b>captured</b></p>
    <p>The captured root node of Captured XML has one target child node, one counters child node, and the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>version</td>
	<td>Integer</td>
	<td><span class="circle">1</span></td>
      </tr>
      <tr>
	<td>live_energy_delta</td>
	<td>Integer</td>
	<td>This attribute is added by Streamline</td>
      </tr>
      <tr>
	<td>created</td>
	<td>Integer</td>
	<td>Capture date in seconds since the epoch (midnight January 1, 1970 UTC). If you are doing a local capture, gator populates this attribute. Otherwise, Streamline adds this attribute.</td>
      </tr>
      <tr>
	<td>protocol</td>
	<td>Integer</td>
	<td><span class="circle">14</span></td>
      </tr>
      <tr>
	<td>backtrace_processing</td>
	<td>String</td>
	<td>The value of backtrace_processing can be either gator or none. This attribute is optional and the default value is gator. Indicates the type of call stack post-processing to use.</td>
      </tr>
    </table></p>
    <p><b>target</b></p>
    <p>The captured node always contains one target child node. The target child node has the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>name</td>
	<td>String</td>
	<td>The name of the target</td>
      </tr>
      <tr>
	<td>sample_rate</td>
	<td>Integer</td>
	<td>Number of samples collected per second</td>
      </tr>
      <tr>
	<td>cores</td>
	<td>Integer</td>
	<td>Number of cores on the target</td>
      </tr>
      <tr>
	<td>cpuid</td>
	<td>Hex Integer</td>
	<td>The cpuid of a core. For example, 0xc08</td>
      </tr>
    </table></p>
    <p><b>counters</b></p>
    <p>The captured node always contains one counters node. The counters node has the following child node:</p>
    <p><b>counter</b></p>
    <p>The counters node can contain any number of counter child nodes. The counter child node contains the following attributes:</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>key</td>
	<td>Hex Integer</td>
	<td>The key for this counter in the APC data.</td>
      </tr>
      <tr>
	<td>type</td>
	<td>String</td>
	<td>The same as the counter attribute in the configuration node of Configuration XML.</td>
      </tr>
      <tr>
	<td>event</td>
	<td>Hex Integer</td>
	<td>The same as the event attribute in the configuration node of Configuration XML.</td>
      </tr>
      <tr>
	<td>count</td>
	<td>Integer</td>
	<td>The count value used during the capture session. Dictated how many samples had to be collected before triggering the event. This can only be set on one counter. This attribute is optional.</td>
      </tr>
    </table></p>
    <p>Example:</p>
    <p class="literal">
      &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>
      &lt;captured version="1" created="1361467764" protocol="14"&gt;<br/>
      &nbsp;&nbsp;&lt;target sample_rate="100" cores="5" cpuid="0xc0f"/&gt;<br/>
      &nbsp;&nbsp;&lt;counters&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x3" type="ARM_Cortex-A7_cnt1" event="0x10"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x4" type="ARM_Cortex-A7_cnt2" event="0x16"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x1" type="ARM_Cortex-A7_ccnt" event="0xff"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x2" type="ARM_Cortex-A7_cnt0" event="0x8"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x15" type="Linux_power_cpu_freq" event="0x0"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x9" type="Linux_block_rq_rd" event="0x0"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x8" type="Linux_block_rq_wr" event="0x0"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0xc" type="Linux_meminfo_memfree" event="0x0"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0xd" type="Linux_meminfo_memused" event="0x0"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x12" type="Linux_net_rx" event="0x0"/&gt;<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&lt;counter key="0x13" type="Linux_net_tx" event="0x0"/&gt;<br/>
      &nbsp;&nbsp;&lt;/counters&gt;<br/>
      &lt;/captured&gt;
    </p>
    <h2 id="Frame">APC Frame Format</h2>
    <h3 id="Overview">Overview</h3>
    <p>The XML files and .apc data collected by Streamline are placed in an .apc folder. When Streamline processes this folder, it creates a db folder, followed by a separate .apd folder.</p>
    <p>Note: The APC files are ten-digit files with no extension starting with 0000000000.</p>
    <p>When creating a new report from the same .apc folder, Streamline does not regenerate the db folder, even if the .apc data has changed. In other words, the .apc data is ignored if a valid db folder exists. To ensure Streamline generates a new report from the .apc data, delete the db directory. If this folder is missing, Streamline recreates it from the .apc data files.</p>
    <h3 id="FrameTypes">Types</h3>
    <dl>
      <dt>int32</dt><dd>4-byte signed little endian</dd>
      <dt>packed32</dt><dd>variable length packed 4-byte signed value, see <a href="#FramePacked">Packed Values</a></dd>
      <dt>packed64</dt><dd>variable length packed 8-byte signed value, see <a href="#FramePacked">Packed Values</a></dd>
      <dt>string</dt><dd>A packed32 length followed by the specified number of characters</dd>
      <dt><span class="circle">#</span></dt><dd>A constant packed32 value of #, ex: <span class="circle">5</span> is the packed32 number 5</dd>
      <dt>timestamp</dt><dd>packed64 time value in nanoseconds relative to the uptime from the <a href="#FrameSummary">Summary Message</a></dd>
    </dl>
    <h3 id="FramePacked">Packed Values</h3>
    <p>To reduce their size, integers are packed. This is done by avoiding the transmission of duplicate high bits. The value is split into 7 bit bytes in little endian order. The most significant bit of the byte is set to 1, if there is a subsequent byte for this value. On the last byte, the most significant bit is set to 0. For positive values, the most signifiant encoded bit must be 0 and for negative numbers it must be 1. This is very similar to signed LEB128 used in DWARF.</p>
    <p><table>
      <tr>
	<th><span class="white">Bits</span></th>
	<th><span class="white">Last value</span></th>
	<th><span class="white">Byte 1</span></th>
	<th><span class="white">Byte 2</span></th>
	<th><span class="white">Byte 3</span></th>
	<th><span class="white">Byte 4</span></th>
	<th><span class="white">Byte 5</span></th>
      </tr>
      <tr>
	<th><span class="white">31</span></th>
	<td>-2147483648</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01111XXXb</td>
      </tr>
      <tr>
	<th><span class="white">27</span></th>
	<td>-134217728</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="3"></td>
      </tr>
      <tr>
	<th><span class="white">20</span></th>
	<td>-1048576</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="2"></td>
      </tr>
      <tr>
	<th><span class="white">13</span></th>
	<td>-8192</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="3"></td>
      </tr>
      <tr>
	<th><span class="white">6</span></th>
	<td>-64</td>
	<td>01XXXXXXb</td>
	<td colspan="4"></td>
      </tr>
      <tr>
	<th><span class="white">6</span></th>
	<td>63</td>
	<td>00XXXXXXb</td>
	<td colspan="4"></td>
      </tr>
      <tr>
	<th><span class="white">13</span></th>
	<td>8191</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="3"></td>
      </tr>
      <tr>
	<th><span class="white">20</span></th>
	<td>1048575</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="2"></td>
      </tr>
      <tr>
	<th><span class="white">27</span></th>
	<td>134217727</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td></td>
      </tr>
      <tr>
	<th><span class="white">31</span></th>
	<td>2147483647</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00000XXXb</td>
      </tr>
    </table></p>
    <p>For example, 429389 (<span style="color:red">011010</span><span style="color:green">0011010</span><span style="color:blue">1001101</span>b) would be encoded as 0xCD (1<span style="color:blue">1001101</span>b) 0x9A (1<span style="color:green">0011010</span>b) 0x1A (00<span style="color:red">011010</span>b)</p>
    <p>Packed 64 values work in much the same way:</p>
    <p><table>
      <tr>
	<th><span class="white">Bits</span></th>
	<th><span class="white">Last value</span></th>
	<th><span class="white">Byte 1</span></th>
	<th><span class="white">Byte 2</span></th>
	<th><span class="white">Byte 3</span></th>
	<th><span class="white">Byte 4</span></th>
	<th><span class="white">Byte 5</span></th>
	<th><span class="white">Byte 6</span></th>
	<th><span class="white">Byte 7</span></th>
	<th><span class="white">Byte 8</span></th>
	<th><span class="white">Byte 9</span></th>
	<th><span class="white">Byte 10</span></th>
      </tr>

      <tr>
	<th><span class="white">63</span></th>
	<td>-9223372036854775808</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>0111111Xb</td>
      </tr>
      <tr>
	<th><span class="white">62</span></th>
	<td>-4611686018427387904</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td></td>
      </tr>
      <tr>
	<th><span class="white">55</span></th>
	<td>-36028797018963968</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="2"></td>
      </tr>
      <tr>
	<th><span class="white">48</span></th>
	<td>-281474976710656</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="3"></td>
      </tr>
      <tr>
	<th><span class="white">41</span></th>
	<td>-2199023255552</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="4"></td>
      </tr>
      <tr>
	<th><span class="white">34</span></th>
	<td>-17179869184</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="5"></td>
      </tr>

      <tr>
	<th><span class="white">27</span></th>
	<td>-134217728</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="6"></td>
      </tr>
      <tr>
	<th><span class="white">20</span></th>
	<td>-1048576</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="7"></td>
      </tr>
      <tr>
	<th><span class="white">13</span></th>
	<td>-8192</td>
	<td>1XXXXXXXb</td>
	<td>01XXXXXXb</td>
	<td colspan="8"></td>
      </tr>
      <tr>
	<th><span class="white">6</span></th>
	<td>-64</td>
	<td>01XXXXXXb</td>
	<td colspan="9"></td>
      </tr>
      <tr>
	<th><span class="white">6</span></th>
	<td>63</td>
	<td>00XXXXXXb</td>
	<td colspan="9"></td>
      </tr>
      <tr>
	<th><span class="white">13</span></th>
	<td>8191</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="8"></td>
      </tr>
      <tr>
	<th><span class="white">20</span></th>
	<td>1048575</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="7"></td>
      </tr>
      <tr>
	<th><span class="white">27</span></th>
	<td>134217727</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="6"></td>
      </tr>
      <tr>
	<th><span class="white">34</span></th>
	<td>17179869183</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="5"></td>
      </tr>
      <tr>
	<th><span class="white">41</span></th>
	<td>2199023255551</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="4"></td>
      </tr>
      <tr>
	<th><span class="white">48</span></th>
	<td>281474976710655</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="3"></td>
      </tr>
      <tr>
	<th><span class="white">55</span></th>
	<td>36028797018963967</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td colspan="2"></td>
      </tr>
      <tr>
	<th><span class="white">62</span></th>
	<td>4611686018427387903</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>00XXXXXXb</td>
	<td></td>
      </tr>
      <tr>
	<th><span class="white">63</span></th>
	<td>9223372036854775807</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>1XXXXXXXb</td>
	<td>0000000Xb</td>
      </tr>
    </table></p>
    <p>For example, -4758616141418899142 would be encoded as 0xBA 0xB2 0xA5 0xA2 0xCE 0xFA 0xFF 0xFA 0xBD 0x7F.</p>
    <p>Frames consist of a header followed by a body of zero or more type specific messages</p>
    <h3 id="FrameOrdering">Ordering</h3>
    <p>The timestamp order of messages is significant and must be in-order on the same core. A specific counter is only be populated in <a href="#FrameCounter">Counter</a> frames or <a href="#FrameBlockCounter">Block Counter</a> frames, not a mix of both.</p>
    <h3 id="FrameRequired">Required Messages</h3>
    <p>To generate a valid capture at least one <a href="#FrameSched">Sched Switch</a>, <a href="#FrameCounter">Counter</a> or <a href="#FrameBlockCounter">Block Counter</a> message must be present. All other messages are optional.</p>
    <h3 id="FrameHeader">Frame Header</h3>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Length</td>
	<td>Little Endian int32</td>
	<td>Number of bytes after the length in the frame</td>
      </tr>
      <tr>
	<td>Code</td>
	<td>packed32</td>
	<td>Indicates the type of this frame.
	  <table class="none">
	    <tr><td>1</td><td>= <a href="#FrameSummary">Summary</a></td></tr>
	    <tr><td>2</td><td>= <a href="#FrameBacktrace">Backtrace</a></td></tr>
	    <tr><td>3</td><td>= <a href="#FrameName">Name</a></td></tr>
	    <tr><td>4</td><td>= <a href="#FrameCounter">Counter</a></td></tr>
	    <tr><td>5</td><td>= <a href="#FrameBlockCounter">Block Counter</a></td></tr>
	    <tr><td>6</td><td>= <a href="#FrameAnnotate">Annotate</a></td></tr>
	    <tr><td>7</td><td>= <a href="#FrameSched">Sched Trace</a></td></tr>
	    <tr><td>8</td><td>= <a href="#FrameGPU">GPU Trace</a></td></tr>
	    <tr><td>9</td><td>= <a href="#FrameIdle">Idle</a></td></tr>
	  </table>
	</td>
      </tr>
      <tr>
	<td>Core</td>
	<td>packed32</td>
	<td>The processor that originated the messages in the frame. This field must always be present but is ignored for <a href="#FrameSummary">Summary</a>, <a href="#FrameCounter">Counter</a>, <a href="#FrameAnnotate">Annotate</a>, <a href="#FrameGPU">GPU Trace</a> and <a href="#FrameIdle">Idle</a> Frames as these frames can have messages from multiple cores.</td>
      </tr>
    </table></p>
    <p>If there are multiple message types for a frame, each message will start with an unique code</p>
    <h3 id="FrameSummary">Summary Frame Messages</h3>
    <p>The summary frame will appear only once and have only have one message. It is recommended that this is the first frame sent to Streamline so the Newline Canary can be checked for correctness before any other processing occurs.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Newline Canary</td>
	<td>string</td>
	<td>Always "1\n2\r\n3\r4\n\r5"</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>packed64</td>
	<td>Current system time in nanoseconds since the epoch (midnight January 1, 1970 UTC) or 0 if the target does not have system time</td>
      </tr>
      <tr>
	<td>Uptime</td>
	<td>packed64</td>
	<td>How long the system has been running in nanoseconds. This is not affected by external influences like changing the system time, ntp, hibernating, etc... Can be used to reference kernel log messages. If the target does not support uptime, send 0 and use a monotonically increasing timer for the timestamp messages.</td>
      </tr>
      <tr>
	<td>Attributes</td>
	<td>&nbsp;</td>
	<td>
	  Zero or more repetitions of the following:
	  <table>
	    <tr>
	      <th><span class="white">Name</span></th>
	      <th><span class="white">Type</span></th>
	      <th><span class="white">Description</span></th>
	    </tr>
	    <tr>
	      <td>Key</td>
	      <td>String</td>
	      <td>Attribute key. Must not be empty</td>
	    </tr>
	    <tr>
	      <td>Value</td>
	      <td>String</td>
	      <td>Attribute value</td>
	    </tr>
	  </table>
	</td>
      </tr>
      <tr>
	<td>End of Attributes</td>
	<td>String</td>
	<td>Always the empty string</td>
      </tr>
    </table></p>
    <h3 id="FrameBacktrace">Backtrace Frame Messages</h3>
    <p>This is used to populate the Call Paths tab</p>
    <ul>
      <li>Exec cookie vs Offset cookie
	<ul><li>If a sample occurs in libx.so called by my-app, the exec cookie is my-app and the offset cookie is libx.so</li></ul>
      </li>
    </ul>
    <p>Cookies should be positive. The special values 0 indicates kernel or idle, -1 indicate an invalid cookie and 1 is reserved to avoid confusion with End of Message, <span class="circle">1</span> below.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Exec Cookie</td>
	<td>packed32</td>
	<td>Cookie of the current process</td>
      </tr>
      <tr>
	<td>pid</td>
	<td>packed32</td>
	<td>Process ID. In Linux, this is the Thread Group ID</td>
      </tr>
      <tr>
	<td>tid</td>
	<td>packed32</td>
	<td>Thread ID. In Linux, this is the PID</td>
      </tr>
      <tr>
	<td>InKernel</td>
	<td>packed32</td>
	<td>
	  <table class="none">
	    <tr><td>0</td><td>= not in kernel</td></tr>
	    <tr><td>1</td><td>= in kernel</td></tr>
	  </table>
	</td>
      </tr>
      <tr>
	<td>Body</td>
	<td>&nbsp;</td>
	<td>
	  One or more repetitions of the following:
	  <table>
	    <tr>
	      <th><span class="white">Name</span></th>
	      <th><span class="white">Type</span></th>
	      <th><span class="white">Description</span></th>
	    </tr>
	    <tr>
	      <td>Offset Cookie</td>
	      <td>packed32</td>
	      <td>Executable or library at the offset</td>
	    </tr>
	    <tr>
	      <td>Offset</td>
	      <td>packed64</td>
	      <td>Offset in the backtrace</td>
	    </tr>
	  </table>
	</td>
      </tr>
      <tr>
	<td>End of Message</td>
	<td><span class="circle">1</span></td>
	<td>&nbsp;</td>
      </tr>
    </table></p>
    <h3 id="FrameName">Name Frame Messages</h3>
    <p><b>Cookie Name Message</b></p>
    <p>This is used to get the name for the Process Handle. Cookies are stored in a pseudo hashmap which limits the number of possible collisions, thus duplicate cookies may be emitted. In addition, cookies are stored per core, thus when a task migrates to a new core, a fresh cookie may be emitted for that core. However cookies are unique across all cores.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">1</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Cookie</td>
	<td>packed32</td>
	<td>Cookie key</td>
      </tr>
      <tr>
	<td>Name</td>
	<td>string</td>
	<td>Cookie value</td>
      </tr>
    </table></p>
    <p><b>Thread Name Message</b></p>
    <p>This is used to show thread names in the Thread Disclosure. Thread names are stored in a pseudo hashmap which to limit the number of times the name is sent, but duplicate thread names may be emitted. Thread numbers can be reused as long as the context switch process free event is sent before it is reused.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">2</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Thread ID</td>
	<td>packed32</td>
	<td>tid of the named thread</td>
      </tr>
      <tr>
	<td>Name</td>
	<td>string</td>
	<td>Name of the thread</td>
      </tr>
    </table></p>
    <p><b>Core Name Message</b></p>
    <p>This is used to identify clusters and in the tooltip in X-Ray mode</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">3</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>cpuid</td>
	<td>packed32</td>
	<td>cpuid of this core. For example, 0xc08</td>
      </tr>
      <tr>
	<td>Name</td>
	<td>string</td>
	<td>Human readable name of this core. For example, Cortex-A8</td>
      </tr>
    </table></p>
    <h3 id="FrameCounter">Counter Frame Messages</h3>
    <p>This is used to populate Charts in the Timeline view</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Core</td>
	<td>packed32</td>
	<td>Core to which this counter applies</td>
      </tr>
      <tr>
	<td>Key</td>
	<td>packed32</td>
	<td>Key in <a href="#XMLCaptured">Captured XML</a></td>
      </tr>
      <tr>
	<td>Value</td>
	<td>packed64</td>
	<td>Value of the specified counter</td>
      </tr>
    </table></p>
    <h3 id="FrameBlockCounter">Block Counter Frame Messages</h3>
    <p>Block counters are the same as counters, but used less space when multiple counters are sampled at the same timestamp and on the same core. To start the block, the key of 0 and a timestamp value is emitted. Then any counters sampled at that time are emitted. A block of counters - counters using the same timestamp - must all be emitted in the same frame. For example, the first block counter message emitted in a frame must be the timestamp.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Key</td>
	<td>packed32</td>
	<td>Zero for timestamp or key in <a href="#XMLCaptured">Captured XML</a></td>
      </tr>
      <tr>
	<td>Value</td>
	<td>packed64</td>
	<td>Value of the specified counter</td>
      </tr>
    </table></p>
    <h3 id="FrameAnnotate">Annotate Frame Messages</h3>
    <p>Annotations are messages sent by arbitrary userspace programs, so their format is different from other messages.</p>
    <p>A single annotation may be broken across frame boundaries. This is why the Annotation Message has a size and the Userspace Annotations either have a size or are '\n' terminated.</p>
    <p>To colorize any ASCII string within the annotation data, prefix the string with 0x1B escape character followed by a 3-byte RGB value</p>
    <p><b>Annotate Message</b></p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Core</td>
	<td>packed32</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>tid</td>
	<td>packed32</td>
	<td>Thread ID (in Linux this is the PID)</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Size</td>
	<td>packed32</td>
	<td>Message size</td>
      </tr>
      <tr>
	<td>Body</td>
	<td>&nbsp;</td>
	<td>Userspace Annotation data fragment</td>
      </tr>
    </table></p>
    <h4>Userspace Annotations</h4>
    <p>Annotations belong to a channel with 0 being the default channel. Channels belong to groups with 0 as the default group.</p>
    <p><b>ASCII String Annotation</b></p>
    <p>This is used to add a line in the Log tab. Can also be sent from the command line. For example, <span class="literal">echo 'Hello World' &gt; /dev/gator/annotate</span></p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Color</td>
	<td>color</td>
	<td>Optional, <span class="circle">0x1B</span>, RR, GG, BB</td>
      </tr>
      <tr>
	<td>ASCII String</td>
	<td>Zero or more ASCII characters followed by '\n'</td>
	<td>Text annotation</td>
      </tr>
    </table></p>
    <p><b>Create Group Annotation</b></p>
    <p>This is used to name a group in the Thread Disclosure</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Escape Code</td>
	<td><span class="circle">0x1C</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Marker Code</td>
	<td><span class="circle">0x8</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Group</td>
	<td>Little Endian int32</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>String Length</td>
	<td>Little Endian int16</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>UTF-8 String</td>
	<td>String Length UTF-8 bytes</td>
	<td>Channel name</td>
      </tr>
    </table></p>
    <p><b>Create Channel Annotation</b></p>
    <p>This is used to name a channel in the Thread Disclosure</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Escape Code</td>
	<td><span class="circle">0x1C</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Marker Code</td>
	<td><span class="circle">0x7</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Channel</td>
	<td>Little Endian int32</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Group</td>
	<td>Little Endian int32</td>
	<td>Group the channel belongs to</td>
      </tr>
      <tr>
	<td>String Length</td>
	<td>Little Endian int16</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>UTF-8 String</td>
	<td>String Length UTF-8 bytes</td>
	<td>Channel name</td>
      </tr>
    </table></p>
    <p><b>UTF-8 String Annotations</b></p>
    <p>This is used to add a line in the Log tab.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Escape Code</td>
	<td><span class="circle">0x1C</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Marker Code</td>
	<td><span class="circle">0x6</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Channel</td>
	<td>Little Endian int32</td>
	<td>Channel the annotation belongs to</td>
      </tr>
      <tr>
	<td>String Length</td>
	<td>Little Endian int16</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Color</td>
	<td>color</td>
	<td>Optional, <span class="circle">0x1B</span>, RR, GG, BB, counts against String Length</td>
      </tr>
      <tr>
	<td>UTF-8 String</td>
	<td>String Length UTF-8 bytes</td>
	<td>Text annotation</td>
      </tr>
    </table></p>
    <p><b>Visual Annotation</b></p>
    <p>This is used to add a line in the Log tab and an image to the Visual Annotation Chart.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Escape Code</td>
	<td><span class="circle">0x1C</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Visual Code</td>
	<td><span class="circle">0x4</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>String Length</td>
	<td>Little Endian int16</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>UTF-8 String</td>
	<td>String Length UTF-8 bytes</td>
	<td>Text annotation</td>
      </tr>
      <tr>
	<td>Image Length</td>
	<td>Little Endian int32</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Image Data</td>
	<td>Image Length bytes</td>
	<td>&nbsp;</td>
      </tr>
    </table></p>
    <p><b>Marker Annotation</b></p>
    <p>This is used to add a Bookmark</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Escape Code</td>
	<td><span class="circle">0x1C</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Marker Code</td>
	<td><span class="circle">0x5</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>String Length</td>
	<td>Little Endian int16</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Color</td>
	<td>color</td>
	<td>Optional, <span class="circle">0x1B</span>, RR, GG, BB, counts against String Length</td>
      </tr>
      <tr>
	<td>UTF-8 String</td>
	<td>String Length UTF-8 bytes</td>
	<td>Text annotation</td>
      </tr>
    </table></p>
    <h3 id="FrameSched">Scheduler Trace Frame Messages</h3>
    <p>As with <a href="#FrameBacktrace">Backtrace Frame Messages</a>, the cookies should be positive. The special cookie value 0, in conjunction of a pid of 0, indicates kernel. A cookie value of 0 and a pid of 1 indicates idle.</p>
    <p><b>Sched Switch</b></p>
    <p>This is used to populate the CPU Activity Chart and the Heat Map</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">1</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>pid</td>
	<td>packed32</td>
	<td>Process ID (in Linux this is the Thread Group ID)</td>
      </tr>
      <tr>
	<td>tid</td>
	<td>packed32</td>
	<td>Thread ID (in Linux this is the PID)</td>
      </tr>
      <tr>
	<td>Cookie</td>
	<td>packed32</td>
	<td>Cookie of the current process</td>
      </tr>
      <tr>
	<td>State</td>
	<td>packed32</td>
	<td>State
	  <table class="none">
	    <tr><td>0</td><td>= Waiting on other event besides I/O</td></tr>
	    <tr><td>1</td><td>= Contention/pre-emption</td></tr>
	    <tr><td>2</td><td>= Waiting on I/O</td></tr>
	    <tr><td>3</td><td>= Waiting on mutex</td></tr>
	  </table>
	</td>
      </tr>
    </table></p>
    <p><b>Sched Thread Exit</b></p>
    <p>This is used by the Heat Map to identify when a process terminates</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">2</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>tid</td>
	<td>packed32</td>
	<td>Thread ID (in Linux this is the PID)</td>
      </tr>
    </table></p>
    <h3 id="FrameGPU">GPU Trace Frame Messages</h3>
    <p><b>GPU Start</b></p>
    <p>This is used to indicate a part of the GPU has begun execution</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">1</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Unit</td>
	<td>packed32</td>
	<td>GPU Unit</td>
      </tr>
      <tr>
	<td>Core</td>
	<td>packed32</td>
	<td>GPU Unit Core</td>
      </tr>
      <tr>
	<td>pid</td>
	<td>packed32</td>
	<td>Process ID (in Linux this is the Thread Group ID)</td>
      </tr>
      <tr>
	<td>tid</td>
	<td>packed32</td>
	<td>Thread ID (in Linux this is the PID)</td>
      </tr>
    </table></p>
    <p><b>GPU Stop</b></p>
    <p>This is used to indicate a part of the GPU has ceased execution</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">2</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Unit</td>
	<td>packed32</td>
	<td>GPU Unit</td>
      </tr>
      <tr>
	<td>Core</td>
	<td>packed32</td>
	<td>GPU Unit Core</td>
      </tr>
    </table></p>
    <h3 id="FrameIdle">Idle Frame Messages</h3>
    <p><b>Enter Idle</b></p>
    <p>This is used to indicate that a core has ceased execution.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">1</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Core</td>
	<td>packed32</td>
	<td>&nbsp;</td>
      </tr>
    </table></p>
    <p><b>Exit Idle</b></p>
    <p>This is used to indicate that a core has resumed execution.</p>
    <p><table>
      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Code</td>
	<td><span class="circle">2</span></td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Timestamp</td>
	<td>timestamp</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td>Core</td>
	<td>packed32</td>
	<td>&nbsp;</td>
      </tr>
    </table></p>
    <h2 id="Sequence">Sequence Diagrams</h2>
    <h3 id="SequenceConfig">Configuration</h3>
    <p>The diagrams in this topic depict the series of events that are triggered when you click various buttons in the Streamline user interface. Here are the events that occur when the Counter Configuration button is clicked in Streamline where $VER is 14</p>
    <img src="config-14.png"/><br/>
    <p>This is the sequence of events when you click the Load Defaults in the Counter Configuration dialog box:</p>
    <img src="config_default.png"/><br/>
    <p>This diagram illustrates the sequence of events that occur when you click either the Cancel or Close button in the Counter Configuration dialog box:</p>
    <img src="config_cancel.png"/><br/>
    <p>This is the sequence of events triggered when the Save button is clicked from the Counter Configuration dialog box:</p>
    <img src="config_save.png"/><br/>
    <p>Note: After you click Save, Cancel or Close, the Counter Configuration dialog box closes.</p>
    <h3 id="SequenceCapture">Capture</h3>
    <p>Here are the events that occur when you click the Start Capture button in Streamline, when the $VER is 14.</p>
    <img src="capture-14.png"/><br/>
    <p>At any point during the capture, Streamline can send a ping to verify that the host is still running. If the ping is not acknowledged, Streamline ends the capture.</p>
    <img src="capture_ping.png"/><br/>
    <h2 id="LocalCapture">Local Capture</h2>
    <p>Streamline also support a local capture mode, a mode in which data is collected without interaction with Streamline. In this case the <a href="#Protocol">Target-Host Protocol</a> is omitted. Instead a directory, ending in .apc, is provided to Streamline. This directory contains captured.xml containing the <a href="#XMLCaptured">Captured XML</a>, session.xml containing the <a href="#XMLSession">Session XML</a>, events.xml containing the <a href="#XMLEvents">Events XML</a> and 0000000000 which contains the <a href="#Frame">APC Data</a> with one or more structures of the following format:</p>
    <p><table>

      <tr>
	<th><span class="white">Name</span></th>
	<th><span class="white">Type</span></th>
	<th><span class="white">Description</span></th>
      </tr>
      <tr>
	<td>Length</td>
	<td>Little Endian int32</td>
	<td>Number of bytes in the body</td>
      </tr>
      <tr>
	<td>body</td>
	<td><a href="#Frame">APC Data</a></td>
	<td>&nbsp;</td>
      </tr>
    </table></p>
    </div>
  </body>
</html>
